package ays

import (
	"fmt"
	"net/http"
	"sync"
	"time"

	log "github.com/Sirupsen/logrus"
	"github.com/patrickmn/go-cache"
	client "github.com/zero-os/0-orchestrator/api/ays/ays-client"
	"github.com/zero-os/0-orchestrator/api/ays/callback"
)

// Client is the main type of this package, it prove an easy to use API on top of the
// AYS client generated by-goraml
type Client struct {
	// the name of the repos
	repo   string
	client *client.AtYourServiceAPI

	// used to manage direct connection to the nodes and containers
	connectionMgr *connectionMgr
	// cache for container ids
	cache *cache.Cache

	iyoOrganization string
	iyoAppID        string
	iyoSecret       string
	token           string
	mu              sync.Mutex

	cbMgr *callback.Mgr
}

// NewClient create a new AYS client for a specific AYS repository
// if token is not empty, the Authorization header will be fill with the token and send for each request
func NewClient(url, repo, org, appID, secret string) (*Client, error) {
	cl := &Client{
		repo:            repo,
		iyoOrganization: org,
		iyoAppID:        appID,
		iyoSecret:       secret,
		mu:              sync.Mutex{},

		cache: cache.New(5*time.Minute, 1*time.Minute),

		client: client.NewAtYourServiceAPI(),
		cbMgr:  callback.NewMgr(fmt.Sprintf("%s/callback", url)),
	}
	cl.connectionMgr = newConnectionMgr(cl)
	cl.client.BaseURI = url

	return cl, nil
}

// AYS service
func (c *Client) AYS() *client.AysService {
	newToken, err := getToken(c.token, c.iyoAppID, c.iyoSecret, c.iyoOrganization)
	if err != nil {
		log.Error("error getting jwt token:", err)
		// return nil, err
	}

	c.mu.Lock()
	defer c.mu.Unlock()
	if c.token != newToken {
		c.token = newToken
		c.client.AuthHeader = fmt.Sprintf("Bearer %s", c.token)
	}

	return c.client.Ays
}

// CallbackHandler function
func (c *Client) CallbackHandler() http.HandlerFunc {
	return c.cbMgr.Handler
}

// CreateExecRun creates and executes a blueprint, and then schedules a run for it.
// If wait == true then this method will also wait until the run and all its reties have finished
// or timeout after 1h
func (c *Client) CreateExecRun(name string, bp Blueprint, wait bool) (*Run, error) {
	if err := c.CreateBlueprint(name, bp); err != nil {
		return nil, err
	}

	if _, err := c.ExecuteBlueprint(name); err != nil {
		return nil, err
	}

	return c.CreateRun(false, wait)
}

// CreateExec creates and executes a blueprint, and waits until the jobs created by AYS have executed
func (c *Client) CreateExec(blueprintName string, blueprint Blueprint) error {
	if err := c.CreateBlueprint(blueprintName, blueprint); err != nil {
		return err
	}

	processJobs, err := c.ExecuteBlueprint(blueprintName)
	if err != nil {
		return err
	}

	return processJobs.Wait()
}
